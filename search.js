var docs = 
{

	"/programing/2018/02/27/lap-trinh-la-cai-quai-gi.html":{
	"id"    : "/programing/2018/02/27/lap-trinh-la-cai-quai-gi.html",
	"title"   : "Lập trình là cái quái gì?",
	"content" : "Một clip ngắn giới thiệu sơ qua về lập trình, giải đáp phần nào thắc mắc của một số bạn chưa hoặc đang bắt đầu chen chân vào cái ngành công nghiệp mồ côi gấu này.Giọng dẫn clip hơi đụt xíu mong mọi người thông cảm. Thời gian tới mình sẽ chỉn chu hơn về clip và âm thanh.Thân ái!"
},

	"/programing/2018/02/27/dong-chay-bien-trong-mo-hinh-mvc.html":{
	"id"    : "/programing/2018/02/27/dong-chay-bien-trong-mo-hinh-mvc.html",
	"title"   : "Dòng chảy của Vars(biến) trong mô hình MVC (Model - control - view)",
	"content" : "Hiện nay để xây dựng 1 Web application thì mô hình MVC là rất phổ biến. Mô hình này có thể thấy ở mọi Framework của các ngôn ngữ lập trình như Ruby, Python, PHP, ASP.Net, NodeJS,… Các Framework đều dự trên mô hình MVC làm chuẩn để hỗ trợ xây dựng Web application vs các gói hỗ trợ cho từng loại ngôn ngữ.Vậy khi xây dựng một Web application người lập trình viên cần nắm rõ nó cũng như nắm được dòng chảy của các biến trong một chương trình để có thể debug và tìm lỗi ngược về nơi nó bắt đầu đến khi nảy sinh lỗi.Vậy dòng chảy chung của vars cho một hệ thống vs mô hình MVC như thế nào?  Giữa M &lt;-&gt; V &lt;-&gt; C:          Ta có thể thấy ngay ở sơ đồ bên dưới: Controllers luôn làm nhiệm vụ xử lý dữ liệu và giao tiếp vs Models để  xử lý dữ liệu và chuyển cho views sau cùng.      Controllers được phép yêu cầu sử dụng views nào và truyền xuống cho views những giá trị vs các tên biến cụ thể.      Models nhận các giá trị từ controllers và xử lý rồi trả ra giá trị controllers cần      Views luôn luôn chỉ nhận giá trị và ko có khả năng xử lý giá trị trả lại cho controllers (lưu ý views là điểm cuối của dòng chảy biến, views chỉ có thể hỗ trợ gửi vars lên controllers bằng các requests từ phí client)        Giữa các block_views và view_layout.                  Với một Web application thì trong views cũng cần có sự kế thừa, dùng lại code nên cơ chế tạo template và render layout là cần thiết. vì vậy trong mô hình MVC, lớp Views luôn luôn hỗ trợ cơ chế này: Một layouts luôn là khung xương chính cho cả Websites, Và các Block_view sẽ hiển thị các thông tin theo yêu cầu của từng page.            Nhìn tổng quan vào hình bên dưới chúng ta sẽ thấy lớp Views ban đầu sẽ được khởi tạo từ một layouts. Và layouts đó bắt đầu include các block_content phù hợp vào để hiển thị, vì thế các giá trị biến trong layout sẽ có thể sử dụng được trong block_content cũng như, layouts sẽ hứng được đầu tiên các giá trị mà controllers truyền xuống      Giữa các block_content thì giá trị thông thường sẽ được sử dụng và truyền theo thứ tự block_content nào được nạp vào trước, block_content nạp sau có thể sử dụng được một số giá trị global của block_content trước đã xử lý.      Đó là những gì tổng quan và cơ bản nhất về dòng chảy của các biến (giá trị) trong mô hình MVC, giúp cho các bạn Lập trình viên có thể tìm hiểu và debug nguyên nhân gây ra lỗi trong hệ thống.Kt: Tan Bui."
},

	"/startup/2016/10/01/startup-de-hay-kho.html":{
	"id"    : "/startup/2016/10/01/startup-de-hay-kho.html",
	"title"   : "Startup dễ hay khó",
	"content" : "Hẳn ai trong chúng ta, tôi hay các bạn khi đã đặt niềm tin lên con đường chinh phục CNTT này, với những đam mê và hoài bão của riêng mình, không ít những con người mong muốn và tâm huyết với những sản phẩm của riêng mình cũng như muốn mình làm chủ được công nghệ cũng như có chân trời riêng để thỏa sức sang tạo và phát triển.Vậy chân trời đó có mới hay không, có là nơi để mỗi người đánh dấu cuộc đời mình không, điều đó chưa thể nói trước điều gì, nhưng chắc hẳn bạn sẽ trưởng thành hơn rất nhiều từ những thất bại cũ và thành công mới.Tôi cũng chưa phải một doanh nhân thành đạt càng chẳng phải một người biết startup làm sao để thành công, và giờ thì tôi cũng mới chỉ chập chững bước chân vào nó với một phương châm “Liều mình và sống hết mình cho đam mê”Thú thực tôi cũng chưa hề có gì để dạy bảo mọi người cũng chả có kinh nghiệm đã giúp mọi người rút ra kinh nghiệm, tôi chỉ có những khó khăn và thành công trước mắt để nói lên mong sẽ giúp mọi người thấy được một phần của con đường “Startup” lúc đầu.Tôi có những đam mê với cái PC cũ kĩ từ bé, từ những phần mềm hữu ích như Paint, PTS hay Word Excel hay các trò game thú vị Line, AOE, CS,… rồi mới đến các ngôn ngữ lập trình. Tôi thường mày mò chúng và luôn đặt câu hỏi tại sao lại làm được như thế và tìm hiểu phân tích xem có những phương án nào để thực hiện được, rồi đến cả tháo tung cái PC còi ra để xem từng con ốc rút ra cắm vào từng chiếc RAM tháo tung cả cái ổ cứng ra rồi để mua một chiếc ổ cứng mới . Và từ lúc đó tôi bắt đầu thích CNTT. Từ đó tôi luôn mong muốn tạo ra các sản phẩm mang dấu ấn của mình cũng như tạo ra chỉ để thỏa mãn mình chứ chưa hề để ý đến quan tâm của người sử dụng khác…Con đường bắt đầu của tôi như thế và giờ tôi đang đối mặt với một hoài bão Startup thành công và câu chuyện từ khi tôi bắt đầu nó như thế nào sẽ là những gì tôi sẽ kể dưới đây.Bắt đầu từ những năm thứ 2 của đại học (thực ra với tôi là năm thứ 3 vì tôi ko thể theo nổi trường cũ mà phải thi lại trường đh mới) khi đó tôi đã thử vọc vạch viết phần mềm, website cũng như tìm hiểu nó với những kiến thức cơ bản mơ hồ về CNTT, tuy nhiên may mắn tôi đã có các sản phẩm đầu tay từ đó và có thể dùng nó để kiếm tiền, nhưng bước đi của tôi lại chưa phải tiền bạc lúc đó, tôi sẵn sàng giúp đỡ các khách hàng thân quen không lấy chi phí để được chạy các sản phẩm chính thức từ đó, vì định nghĩa rằng đó là chính họ đang giúp tôi phát triển mình vậy nên mình ko mất học phí là rất may rồi.Thời điểm đó tôi cũng được các thầy cô trong trường giúp đỡ chú ý để làm các sản phẩm ngắn hạn cho trường của tôi, và công việc cứ ngày một nhiều thì tôi nhận ra rằng các đàn anh đi trước của tôi cũng có những Team khỏe nhận outsource về làm để rồi tôi quyết định mình cần có một Team riêng cho mình từ đó, vừa để ae có thể train vừa là những bước đầu mình thử đứng vai trò một người nhận outsource thực thụ.Khởi đầu khá tốt khi tôi đã có 1 Team 4 người bạn cùng với 2 order từ phía nhà trường. Chúng tôi thực hiện chúng với hết khả năng và vốn kiến thức mình có để rồi 2 sản phẩm ra lò được hưởng ứng rất nhiều cũng như đã có những khoản hỗ trợ đầu tay cho ae ko còn phải trà đá mà là trà tranh khi đóCông việc cứ như thế, nhưng dần thì công việc vẫn duy trì nhưng đổi lại càng về gần năm cuối thì các bạn của tôi càng bận học hành hơn cũng như ko thể theo được team nữa, tôi lại ngậm ngùi cày cuốc một mình. Những tưởng qua thời gian ấy thì mọi người sẽ lại sát cánh bên tôi, nhưng không thể, các bạn đều cần một công ty thực tập riêng cho mình và có thể là apply ngay tại đó. Lúc này quyết định của tôi cũng là apply tới các công ty tìm kinh nghiệm mới, nguồn thu mới và tìm hiểu những con người mới. May mắn cho tôi là lúc này đã có nhiều khách hàng hơn với kinh phí lớn hơn để tôi nhận và vấn đề khó khăn nhất với tôi ở đây lại sẽ là nhân lực. Tôi quyết định gây dựng lại team từ đó, nhưng với lần này thì chúng tôi hoạt động một cách chuyên nghiệp hơn với những người bạn không còn gì để mất mà chỉ cần train và train thật nhiều để mong muốn có KN khi sắp ra trường. Outsource về càng nhiều thì tôi lại càng toan tính với những việc xây dựng hình ảnh cho nhóm, cũng như tích cực liên hệ với các khách hàng mới không còn là những người thân quen nữa, đó cũng là canh bạc mà tôi muốn đánh đổi với nó để sau này có chân trời riêng của mình.Thời gian trôi rất nhanh tôi vẫn duy trì được team ổn định và đang phải đối phó với những khó khăn mới là các bạn đã ra trường và nếu cứ hoạt động như thế này thì tâm huyết của các thành viên sẽ là ở các công ty các bạn đang apply kia chứ ko hoàn toàn ở nơi này. Cũng như với kiểu outsource ăn chia như vậy thì chúng tôi mãi mãi là một team và khó có thể thực hiện đc những ước mơ hoài bão của riêng mình. Tôi đã tìm đến và lắng nghe người anh, người đồng nghiệp thân thiết của tôi, người mà sẵn sàng giúp tôi về tinh thần lẫn tài chính để có thể có hướng giải quyết, dù người đó có thể sẽ xuất ngoại chứ ko còn ở lại bên tôi. Đó là những lời khuyên, lời khích lệ quý giá để tới đây, chúng tôi sẽ bắt đầu với những văn phòng nho nhỏ, để các bạn lại quay về với tôi cùng tôi bước đi những bước đầu tiên. Tuy rằng tôi sẽ càng phải lo lắng nhiều thứ hơn cho lần Startup này, từ nguồn outsource đến tiền lương cho các bạn vì đây sẽ như là một công việc thực thụ của mọi người chứ ko còn là nơi kiếm thêm thu nhập nữa.// Đó là những bước đầu, những điều mà tôi đang sắp phải thực hiện sẽ đến và nó sẽ là những tâm sự về Startup part 2 để giúp các bạn phần nào hiểu hơn về con đưỡng tôi hay chính bạn sẽ bước đi.T/g: Tan Bui"
},

	"/android/2016/07/02/android-windhotspot.html":{
	"id"    : "/android/2016/07/02/android-windhotspot.html",
	"title"   : "Android - WindHotspot",
	"content" : "Bind and Unbind custom everyone events with everyone arguments method in everywhere (free style like JS)Version 0.0.1 Description in githubMaven&lt;dependency&gt;  &lt;groupId&gt;xyz.windjs.android&lt;/groupId&gt;  &lt;artifactId&gt;WindHotspot&lt;/artifactId&gt;  &lt;version&gt;0.0.1&lt;/version&gt;  &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt;Gradlerepositories {  jcenter()}dependencies {  compile &#39;xyz.windjs.android:WindHotspot:0.0.1&#39;}Init for use itWindHotspot.init(); // Use it from onCreate Application or Activity only oneRegister event#1Call call = new Call() {            @Override            public void run(Object... objectes) {                if(objectes.length &gt; 1) Log.d(&quot;OK Event&quot;, (String) objectes[0]); //String object follow with object u call event            }        };WindHotspot.getInstance().bind(&quot;TestEvent&quot;, call);#2class YourClass implements Call{        public YourClass(){      WindHotspot.getInstance().bind(&quot;TestEvent&quot;, this);    }    @Override    public void run(Object... objectes) {        Log.e(&quot;FUCK&quot;, (String) objectes[0]);    }}Unbind EventWindHotspot.getInstance().unbind(&quot;TestEvent&quot;, call);"
},

	"/nodejs/2014/10/31/wnodejs-version-2.html":{
	"id"    : "/nodejs/2014/10/31/wnodejs-version-2.html",
	"title"   : "WNodeJS Framework Verions 2",
	"content" : "Version 2.0.1 Description in npmWhat new?  Create multi application  Manager and render View  Manager and config Model  Create Controller and Action inside controller  Manager and process params, args from url  Open socket.io  Supporter Interface for Controller to render view.  Supporter require mores Object for using  Supporter extends, implement, interface method for Class.  Manager sessionApplication tree source  All application inside app folder  app  ├── api  │   ├── controllers  │   │   └── ... //home.js  │   ├── init.js  │   └── models  └── demo      ├── controllers      │   ├── ... //home.js      ├── init.js      ├── models      │   └── ... //auth_users.js      ├── modules      │   └── ...      ├── static      │   ├── css      │   │   ├── ...      │   ├── ...      │   └── js      │       ├── ...      └── views          ├── ..."
},

	"/nodejs/js/2014/10/20/blocking-vs-nonblocking.html":{
	"id"    : "/nodejs/js/2014/10/20/blocking-vs-nonblocking.html",
	"title"   : "Blocking vs Non-blocking",
	"content" : "Trong lập trình ứng dụng hẳn là ai cũng phải đau đầu với vấn đề Blocking hay Non Blocking. Sẽ có nhiều lúc bạn chả hiểu vì sao chương trình của mình lại chạy không như ý muốn, khi thì câu lệnh này chạy trước, khi thì câu lệnh kia lại chạy trước (và nó thường gặp khi bạn dính phải cơ chế bất đồng bộ - non blocking):Blocking tức đồng bộ:      Để hiểu một cách đơn giản về Blocking thì chúng ta có thể liên tưởng đến hình ảnh xếp hàng thời bao cấp, từng người lần lượt từ trước đến sau sẽ đi lên sử dụng tem phiếu. Vậy trong code sẽ như thế nào? Tất nhiên các dòng lệnh sẽ được chạy lần lượt từ trên xuống dưới 1 cách chờ đợi nhau, khi dòng trên kết thúc thì dòng tiếp theo mới được phép bắt đầu thực hiện. Việc đó đúng ngay cả khi ta sử dụng 2 câu lệnh gọi 2 hàm khác nhau. Chúng sẽ thực hiện lần lượt kết thúc functions 1 rồi đến functions 2.        1 Ví dụ trên Javascript:  function a(){	//do something blocking.}function b(){	//do something blocking.}function main(){	//blocking code, call function a() end to call function b().	a();	b();}Non Blocking tức bất đồng bộ:  Nếu ai đó đã tiếp xúc với khái niệm Thread(Luồng) và Multi Thread (Đa luồng) hay xử lý đa luồng trong lập trình ứng dụng thì cũng sẽ hiểu Non Blocking nó sẽ gần giống như thế. Tức là với đa luồng ta có thể cho 2 luồng chạy song song nhau, có hoặc không liên quan đến giá trị biến chung của nhau đang chiếm giữ. Và Non blocking cũng giống như đoạn code đang chạy blocking bỗng mở một luồng chạy riêng ra và xử lý song song vs các đoạn code sau mà ko bắt chúng chờ đợi.Đó chính là nguyên nhân tại sao mà đôi khi các bạn sẽ gặp những vấn đề rằng giá trị không như mong muốn. và điển hình mình sẽ ví dụ Non blocking và sự thay đổi giá trị của nó ntn trên JS + Ajax (Jquery) - Lý do vì sao mình chọn Ajax vs Jquery vì nó sẽ cho chúng ta thấy dễ nhất và hầu như các bạn sử dụng Ajax của Jquery đều từng phải đau đầu vì chả hiểu sao biến của mình nó mất tiêu, hay cũng như timeout của nó đủ để chúng ta nhìn ngay thấy sự thay đổi:var global_tmp = 0;$.ajax({	url: &#39;http://sample.demo/api&#39;,	success: function(data){		for(var i=0; i&lt;100; i++){			global_tmp = i;		}		console.log(&#39;SUCCESS&#39;, global_tmp);	},	error: function(err){		for(var i=0; i&lt;100; i++){			global_tmp = i;		}		console.log(&#39;ERR&#39;, global_tmp);	}});console.log(&#39;END&#39;, global_tmp);Nếu xét theo phương diện blocking. Thì chúng ta sẽ show ra END cuối cùng và lúc này biến global_tmp đã thay đổi dù ajax có get được hay không. và blocking thì giá trị của chúng ta sẽ là 100Tuy nhiên. với mặc định Ajax trong Jquery sẽ là Non-blocking hay khái niệm Asynctask.và chúng ta sẽ nhận việc in ra màn hình END vs global_tmp không phải giá trị như ta nghĩ - Lý do là Task làm việc thay đổi giá trị của biến đang được tách thành luồng khác và chạy song song với các dòng lệnh tiếp theo.Bonus: xử lý thế nào để không bị như vậy?  Thứ nhất các bạn có thể tìm hiểu về khái niệm Callback trong JS và tất nhiên sử dụng biến trong hàm callback chứ ko đặt ngoài như vậy  Và còn nữa, jquery hỗ trợ bạn gọi với cơ chế blocking bằng cách đưa thêm 1 params vào cho nó là: {async: false}var global_tmp = 0;$.ajax({	url: &#39;http://sample.demo/api&#39;,	async: false,	success: function(data){		for(var i=0; i&lt;100; i++){			global_tmp = i;		}		console.log(&#39;SUCCESS&#39;, global_tmp);	},	error: function(err){		for(var i=0; i&lt;100; i++){			global_tmp = i;		}		console.log(&#39;ERR&#39;, global_tmp);	}});console.log(&#39;END&#39;, global_tmp); :) Và khi đó bạn thoải mái gọi ở dòng lệnh bên dưới như thế này 1 cách bình thường."
},

	"/blog/2014/09/14/tam-ly-ngai-chia-se.html":{
	"id"    : "/blog/2014/09/14/tam-ly-ngai-chia-se.html",
	"title"   : "Tâm lý ngại chia sẻ",
	"content" : "Ngành CNTT hay vốn bản chất được đi lên từ ngành Khoa học máy tính với những nhu cầu tính toán số học của con người, từ những chiếc máy tính điện tử đầu tiên như ENIAC (ra đời năm 1946) là một thiết bị khổng lồ nặng hàng tấn, mãi đến 1970 người ta bắt đầu nghiên cứu ra mạng viễn thông để kết nối và liên lạc các máy tính lại với nhau, cùng với sự phát triển không ngừng nghỉ Internet được ấp ủ từ đó cho đến những năm 1994 có được kết nối TCP/IP và 1991 chúng ta có WWW (Một ý tưởng về siêu văn bản để có được những website ngày hôm nay). Sau đó là 1994 TCP/IP được quy chuẩn, chúng ta có những Video chia sẻ đầu tiên trên mạng Internet. Cùng với sự phát triển đó thì Việt Nam cũng hoà vào mạng Internet toàn cầu năm 1997 sau những cố gắng từ năm 1994.Nhìn chung là vậy nhưng để Internet bây giờ phát triển tại Việt Nam hay toàn thế giới chóng mặt như vậy chúng ta không thể không kể đến những sự chia sẻ của cộng đồng từ những ngày đầu tiên cho đến tận bây giờ đã có rất nhiều những công nghệ mới mà chúng ta phải luôn luôn tìm tòi và học hỏi nó.Học ở đâu? thì câu trả lời rõ ràng đó là từ Internet.Vì sao CNTT lại được Ấn Độ chú trọng đưa vào một trong những ngành công nghiệp trọng điểm thì câu trả lời là ở sự lớn mạnh của CNTT bây giờ. Cũng như chúng ta có thể thoải mái tham gia vào những cộng đồng CNTT lớn mạnh trên toàn thế giới để học hỏi và chia sẻ mà không hề tốn kém chi phí đi lại hay học phí cả.Tôi bước vào Công nghệ thông tin (CNTT) từ khi còn rất nhỏ, và mọi thứ luôn bắt đầu từ con số 0 tròn trĩnh. Để có được những bước tiến như ngày hôm nay thì việc không ngừng cố gắng học hỏi và chia sẻ là không thể thiếu. Và ở đâu chúng ta có được những sự chia sẻ quý báu đó, đó chính ở tâm lý “không ngại” chia sẻ của mỗi cá nhân mong muốn học hỏi.Tôi cũng đã gặp gỡ nhiều người, tiếp xúc và sẻ chia với họ. Và tôi vẫn luôn thắc mắc có những người không hề ngại khó, luôn luôn học hỏi và sẵn sàng chia sẻ với người khác, đó là số ít. Còn lại tâm lý chung những người có bề dày kiến thức lại ít chia sẻ kinh nghiệm của bản thân, hay nói cách khác họ thường lắng nghe nhiều hơn để biết thêm được nhiều cho bản thân chứ chưa chắc giúp bản thân đối phương có được nhiều kiến thức hơn.Cũng có những người thì hiểu biết quá ít nên không hề chia sẻ giống như một dạng tâm lý ngại chia sẻ kiểu “giấu dốt”, vì chính họ sợ rằng khi nói ra sẽ bị người khác so sánh và không tôn trọng. hay ở chính bản thân những người mong muốn được chia sẻ lại không thể tìm đến nhau.Đó cũng là câu chuyện trải nghiệm khi tôi trải qua khá nhiều công ty về CNTT ở Việt Nam hiện nay. Tôi đều may mắn được gặp các bạn thực tập viên, sinh viên đang học và chia sẻ kinh nghiệm chuyên ngành của mình với các bạn, và không quên nhắn nhủ rất nhiều rằng tôi luôn luôn sẵn sàng chia sẻ hay hỗ trợ các bạn tìm hiểu bất cứ khi nào các bạn gặp khó, cũng như luôn luôn tiếp thu các kiến thức mới khi các bạn biết mà tôi cũng chập chững tìm hiểu để cùng nhau tiến bộ. Và tất nhiên sau những lần đó thì kết quả rằng con số tìm đến tôi chỉ có thể đếm trên đầu ngón tay (cũng tốt vì dù sao mỗi đầu ngón tay đó đều có sự tiến triển rõ ràng). Vậy tôi đi tìm nguyên nhân cho chính những kết quả đó thì có chia rằng tâm lý “ngại chia sẻ” được chia làm 3 loại chính:Ngại làm phiền (vì chính bản thân các bạn không hề muốn bị làm phiền),Giấu dốt hay giấu kiến thức (nguyên do rằng các bạn luôn tự ti về bản thân mà sợ chia sẻ với người khác sẽ làm mình kém đi hoặc cũng như bị người khác vượt qua), Thiếu lòng tin hay kiêu ngạo (bản thân bạn tự cảm thấy mình giỏi và người khác không thể làm được, cũng như cảm thấy rằng không tin tưởng đối phương sẽ cùng giúp cho cả 2 tiến bộ lên)Tuy nhiên nhìn về khía cạnh con người chúng ta trong những giai đoạn thăng trầm phát triển của đất nước, chiến tranh, áp bức bóc lột rồi đến sự phân hoá giàu nghèo làm cho con người ta bớt gần lại với nhau, ít chia sẻ với nhau đi. để mãi không thể thoát ra khỏi cái tâm lý “ngại chia sẻ”."
},

	"/github/2014/09/06/welcome.html":{
	"id"    : "/github/2014/09/06/welcome.html",
	"title"   : "Welcome",
	"content" : "Hi everybody, I’m welcome you to views github pages of me.I’m developer all platform and i’m always trying, trying learn to the good developer.Here, I’m shares somethings I know and some projects make by me.Thanks for viewers.def begining  puts &#39;welcome everybody&#39;end"
},

	"/developer/2014/09/06/nguyen-tac-co-ban-trong-xay-dung-he-thong-server.html":{
	"id"    : "/developer/2014/09/06/nguyen-tac-co-ban-trong-xay-dung-he-thong-server.html",
	"title"   : "Nguyên tắc quan trọng trong xây dựng hệ thống (server)",
	"content" : "  Ghi log chi tiết tất cả mọi thứ, mọi lúc. Dữ liệu log trong database tránh tham chiếu đến các bảng db khác mà lưu giá trị cụ thể, ví dụ: log product thì ngoài product id phải lưu cả product_price, product_title… để tránh các giá trị thay đổi theo thời gian bởi người dùng  Xây dựng hệ thống error trace chi tiết và rõ ràng phục vụ cho debug và dễ dàng xóa bỏ khi deploy  Quản lý danh sách các tài khoản test, sandbox để dễ dàng và chính xác trong việc thống kê và remove khi deploy chính thức  Cung cấp hệ thống bảo mật, xác thực ngay từ đầu 1 cách tổng quát cho chức năng, tài khoản truy cập, token cho bên thứ 3 để quản lý việc ai được sử dụng chức năng…, ghi log truy cập của người dùng… Ví dụ cp muốn sử dụng api thì phải đăng ký api_key dành riêng cho mỗi cp, giúp cho việc log và quản lý dễ dàng, bảo mật…  Luôn luôn backup dữ liệu:          source qua svn bằng cách tạo quy trình deployment với branchs, tags…    Ví dụ: khi deploy product thì cần:   . tạo 1 bản tag theo version kèm ngày tương ứng 1.0.20140109, 2.3.20140103…    . sau đó export ra thư mục deployment   khi cần sửa 1 chức năng nhỏ trong bản release 1.0.20130518 mà source đang phát triển cho 2.0 rồi thì cần:   . tạo 1 bản branch từ bản tag 1.0.20130518 với tên là “version_mục_đích_thay_đổi”   . sau đó sửa trên bản branch đến khi hoàn thiện   . cập nhật sang source trunk   . tạo tag với version cũ và ngày release vd: 1.0.20130624   . backup thư mục source deployment vào 1 thư mục backup với tên thư mục là ngày tháng năm backup như 20140901   . export đè vào thư mục source deployment      databases backup tự động định kỳ hàng ngày/tuần/tháng      backup databases manual mỗi lần nâng cấp hệ thống, test hệ thống        Luôn sao database chính ra 1 db tạm khi thử chức năng mới mà có kết nối đến db kể cả có chỉnh sửa db hay ko  Tạo thư mục source, database, tk riêng cho mỗi developer trong quá trình dev, ko dùng chung với db và deployed source  Lưu tất cả tài khoản liên quan đến hệ thống như tk server, database, svn, quản trị… xuống note, server hoặc lưu trữ vào bất kỳ nơi nào an toàn, đảm bảo và cập nhật ngay khi có sự thay đổi  Nghiêm chỉnh chấp hành các quy trình bảo mật và an toàn dữ liệu trên dù chỉ thay đổi nhỏ hoặc đơn giản"
},

	"/language/2014/09/06/ngon-ngu-lap-trinh-nao-tot-nhat.html":{
	"id"    : "/language/2014/09/06/ngon-ngu-lap-trinh-nao-tot-nhat.html",
	"title"   : "Ngôn ngữ lập trình nào tốt nhất?",
	"content" : "Xin chào các bạn, nếu các bạn đến với bài viết vì vì cái câu hỏi vu vơ kia và cũng chỉ để xem ngôn ngữ lập trình nào là tốt nhất, để rồi đắc ý khoe khoang thứ ngôn ngữ mình đang theo là đỉnh cao nhất, là anh cả của các ông dung ngôn ngữ khác, thì thực sự xin lỗi bạn sẽ không tìm được thứ như mình mong muốn đâu.Vậy, ngôn ngữ lập trình nào tốt nhất, mình xin mạo muội nói rằng các bạn không thể đem so sánh ngôn ngữ nào hơn ngôn ngữ nào, vì đơn giản mỗi ngôn ngữ lập trình đều có điểm mạnh điểm yếu riêng, cũng như nó thích hợp với từng nền tảng khác nhau, chả ai đem Passcal đi để lập trình web cả, cũng chả ai đem PHP để viết mấy cái chương trình console tính toán cơ bản đâu.Vậy tại sao vẫn phân các ngôn ngữ lập trình làm chi, sao không làm 1 cho tất cả: thực ra thì mình nghĩ điều này ai chả muốn, nhưng mọi người hãy xem rằng khi lập trình mới nhen nhóm phát triển thì có hàng trăm nghìn tổ chức cùng phát triển, nó sẽ rẽ nhiều nhánh khác nhau, và tất nhiên nó sẽ không thể hợp nhất được. điều các bạn cần là hãy làm đi, và cần những gì để đủ làm với nó, đó chính là kiến thức về hướng đối tượng, kĩ năng thao tác với hệ cơ sở dữ liệu và các thuật toán tối ưu siêu dị của chính bạn là chìa khóa để trở thành những người Dev tốt nhất…Và điều quan trọng để bạn tiếp cận các ngôn ngữ đó là hiểu nó là gì, thông dịch, biên dịch hay có hướng đối tượng hay không? Để có thể lựa chọn phù hợp nhất cho sản phẩm sắp phát triển của bạn. Vậy tiếp theo mình sẽ nói sơ qua về các khái niệm phân biệt ngôn ngữ lập trình kia cho những bạn nào đang quan tâm:Thông dịch hay biên dịch:      Thông dịch là gì? Thông dịch hay còn có thể gọi là ngôn ngữ hướng dòng, Nghĩa là khi chương trình của bạn chạy, thì sẽ chẳng cần qua khâu biên dịch mà chạy được ngay, đến dòng nào nó làm công việc đó, và đến dòng lỗi chương trình sẽ đứng lại không đi tiếp (Chúng ta ko đề cập tới sử dụng khái niệm ‘ngoại lệ’ ở đây nhé), thông dịch phổ biến ở các ngôn ngữ lập trình web như PHP, Python hay ở Ngôn ngữ máy huyền thoại Assembly mà ko phải ai cũng dám sờ vào nó/ Với những loại này thì hiệu quả chương trình với hiệu năng thời gian nhanh hơn hẳn, vì chẳng mất thời gian để build chương trình cũng như code đến đâu test luôn đến đó. Cơ chế bảo mật ko thể cao hơn biên dịch, dễ dàng bỏ sót các lỗi Sytax Error trong lập trình.        Biên dịch là gì? Biên dịch lại đi ngược với thông dịch, trước khi chương trình được chạy thì nó cần được biên dịch thành 1 tệp tin chương trình trước, và quá trình này sẽ rà soát các lỗi Sytax Error để ko cho phép chương trình được biên dịch nếu còn lỗi cú pháp. Và tất nhiên thời gian cho các chương trình này sẽ cần thời gian biên dịch chương trình trước, cũng như cần khai báo 1 hàm main để chương trình chạy nó trước (Không giống với thông dịch, chạy file nào thì thực hiện lệnh ở đó, không cần khai báo hàm main). Và tất nhiên biên dịch sẽ không thể gặp lỗi cú pháp khi chương trình chạy cũng như bảo mật tốt hơn. Những ngôn ngữ biên dịch phổ biến như: C++, C#, Java.  Vậy còn hướng đối tượng hay hướng cấu trúc:      Hầu hết các ngôn ngữ hiện nay đều là hướng đối tượng trừ C thì vẫn hướng cấu trúc, và hiểu nôm na hướng đối tượng giống như một kiểu mở rộng của hướng cấu trúc.        Hướng cấu trúc là các khối lệnh được sử dụng nhiều lần sẽ được nhóm lại thành một hàm xử lý riêng biệt và được dùng lại mỗi khi cần, cũng như các câu lệnh sẽ được thực thi theo trình tự hay lặp đi lặp lại nhiều lần.        Còn hướng đối tượng thì được mở rộng hơn với các Lớp, đối tượng và Khái niệm đóng gói, Hay có thể là Blocking hay Non-Blocking, Và đây chính là giải pháp để chúng ta có thể phát triển các ứng dụng với sự phân cấp các chức năng sâu hơn, rõ ràng hơn hay thể hiện gần sát nhất với chức năng của từng đối tượng cũng như thể hiện sự liên quan của các đối tượng tới nhau như kế thừa, kết tập và có thể tạo nhiều đối tượng có các hành động gần giống nhau mà lại mang các thuộc tính khác nhau…  Trên đây là ý kiến chủ quan của mình về những khái niệm căn bản trong lập trình, mong rằng giúp ích cho các bạn, hẹn gặp lại các bạn trong bài viết tiếp theo.K.T Buminta."
},

};
// init lunr
var idx = lunr(function () {
	this.field('title', {boost: 10});
	this.field('content');
	this.ref('id');
})
// add each document to be index
for(var index in docs) {
	var tmp = {
		id: docs[index].id,
		title: locdau(docs[index].title),
		content: locdau(docs[index].content)
	};
	idx.add(tmp);
}

function locdau(str_in){
	var str = str_in;
	str= str.toLowerCase();
	str= str.replace(/à|á|ạ|ả|ã|â|ầ|ấ|ậ|ẩ|ẫ|ă|ằ|ắ|ặ|ẳ|ẵ/g,"a");
	str= str.replace(/è|é|ẹ|ẻ|ẽ|ê|ề|ế|ệ|ể|ễ/g,"e");
	str= str.replace(/ì|í|ị|ỉ|ĩ/g,"i");
	str= str.replace(/ò|ó|ọ|ỏ|õ|ô|ồ|ố|ộ|ổ|ỗ|ơ|ờ|ớ|ợ|ở|ỡ/g,"o");
	str= str.replace(/ù|ú|ụ|ủ|ũ|ư|ừ|ứ|ự|ử|ữ/g,"u");
	str= str.replace(/ỳ|ý|ỵ|ỷ|ỹ/g,"y");
	str= str.replace(/đ/g,"d");
	str= str.replace(/!|@|\$|%|\^|\*|\(|\)|\+|\=|\<|\>|\?|\/|,|\.|\:|\'| |\"|\&|\#|\[|\]|~/g,"-");
	str= str.replace(/-+-/g,"-");
	str= str.replace(/^\-+|\-+$/g,"");
	str= str.replace("/-/g", " ");
	return str;
}
